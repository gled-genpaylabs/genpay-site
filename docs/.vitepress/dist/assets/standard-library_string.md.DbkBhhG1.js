import{_ as t,c as o,o as r,ae as s}from"./chunks/framework.B8KKhRA6.js";const h=JSON.parse('{"title":"@string","description":"","frontmatter":{},"headers":[],"relativePath":"standard-library/string.md","filePath":"standard-library/string.md"}'),c={name:"standard-library/string.md"};function n(a,e,i,p,l,d){return r(),o("div",null,e[0]||(e[0]=[s(`<h1 id="string" tabindex="-1">@string <a class="header-anchor" href="#string" aria-label="Permalink to &quot;@string&quot;">​</a></h1><p>Dynamic heap allocated string.</p><h2 id="struct-string" tabindex="-1"><code>struct String</code> <a class="header-anchor" href="#struct-string" aria-label="Permalink to &quot;\`struct String\`&quot;">​</a></h2><div class="language-genpay vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">genpay</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ptr: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*char</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">line: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">usize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">len: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">usize</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">iterator_ptr: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">usize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span></code></pre></div><p><strong>Methods:</strong></p><blockquote><p><code>fn new() String</code> <br> Creates new empty string instance.</p></blockquote><hr><blockquote><p><code>fn from(value: *char) String</code> <br> Creates new string from CStr value (char pointer).</p></blockquote><hr><blockquote><p><code>fn from_raw_parts(ptr: *void, len: usize, capacity: usize) String</code> <br> Creates new string from provided pointer, length and capacity.</p></blockquote><hr><blockquote><p><code>fn with_capacity(capacity: usize) String</code> <br> Creates new empty string with provided capacity.</p></blockquote><hr><blockquote><p><code>fn clone(&amp;self) String</code> <br> Clones string instance (allocates new heap string and copies value).</p></blockquote><hr><blockquote><p><code>fn clone_reversed(&amp;self) String</code> <br> Clones string instance with reversed content.</p></blockquote><hr><blockquote><p><code>fn len(&amp;self) usize</code> <br> Returns string&#39;s length.</p></blockquote><hr><blockquote><p><code>fn capacity(&amp;self) usize</code> <br> Returns string&#39;s capacity.</p></blockquote><hr><blockquote><p><code>fn push(&amp;self, value: char)</code> <br> Appends provided character to the end of string.</p></blockquote><hr><blockquote><p><code>fn push_str(&amp;self, value: *char)</code> <br> Appends CStr value to the end of string.</p></blockquote><hr><blockquote><p><code>fn push_string(&amp;self, other: String)</code> <br> Appends other <code>String</code> content to the end of current.</p></blockquote><hr><blockquote><p><code>fn pop(&amp;self) char</code> <br> Removes last character and returns it. If empty returns &#39;\\0&#39;</p></blockquote><hr><blockquote><p><code>fn remove(&amp;self, position: usize)</code> <br> Removes character on specified position (capacity doesn&#39;t change).</p></blockquote><hr><blockquote><p><code>truncate(&amp;self, new_len: usize)</code> <br> Truncates string&#39;s length (capacity doesn&#39;t change)</p></blockquote><hr><blockquote><p><code>fn peek(&amp;self, position: usize) char</code> <br> Returns character on provided position. Panic if out of bounds.</p></blockquote><hr><blockquote><p><code>fn set(&amp;self, position: usize, value: char)</code> <br> Replaces character on <em>position</em> with provided value. Panic if out of bounds.</p></blockquote><hr><blockquote><p><code>fn contains(&amp;self, value: char) bool</code> <br> Returns <code>true</code> if string instance contains provided char.</p></blockquote><hr><blockquote><p><code>fn contains_str(&amp;self, value: *char) bool</code> <br> Returns <code>true</code> if string instance contains provided CStr value.</p></blockquote><hr><blockquote><p><code>fn replace(&amp;self, from: *char, to: *char)</code> <br> Replaces string occurences with provided CStr value.</p></blockquote><hr><blockquote><p><code>find(&amp;self, pattern: char) usize</code> <br> Finds provided character in string and returns its index.</p></blockquote><hr><blockquote><p><code>find_str(&amp;self, pattern: *char) usize</code> <br> Finds provided CStr occurence and returns index of its first character.</p></blockquote><hr><blockquote><p><code>to_uppercase(&amp;self) String</code> <br> Returns clone of string instance in uppercase format.</p></blockquote><hr><blockquote><p><code>to_lowercase(&amp;self) String</code> <br> Returns clone of string instance in lowercase format.</p></blockquote><hr><blockquote><p><code>to_bytes(&amp;self) Bytes</code> (from <code>stdlib.bytes</code>) <br> Returns string instance represented in <code>Bytes</code> structure.</p></blockquote><hr><blockquote><p><code>clear(&amp;self)</code> <br> Clears string (capacity doesn&#39;t change).</p></blockquote><hr><blockquote><p><code>reverse(&amp;self)</code> <br> Reverses string content.</p></blockquote><hr><blockquote><p><code>is_empty(&amp;self)</code> <br> Returns if string content is empty.</p></blockquote><hr><blockquote><p><code>fn as_ptr(&amp;self) *char</code> <br> Returns raw heap pointer.</p></blockquote><p><strong>Compiler Implementations:</strong></p><ul><li><code>fn display(&amp;self) *char</code></li><li><code>fn drop(&amp;self)</code></li><li><code>fn iterate(&amp;self) (char, bool)</code></li><li><code>fn compare(&amp;self, other: *String) i32</code></li><li><code>fn slice(&amp;self, index: usize) char</code></li><li><code>fn slice_assign(&amp;self, index: usize, value: char)</code></li><li><code>fn deref(&amp;self) *char</code></li></ul><p>For more information see <a href="/advanced/structures-implementations.html">Structures Implementations</a></p>`,63)]))}const b=t(c,[["render",n]]);export{h as __pageData,b as default};
